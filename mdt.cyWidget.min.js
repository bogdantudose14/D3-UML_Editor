(function (mdt, $) {
  $.widget('mdt.cyWidget', $.mdt.appWidget, {
    //#region STATIC MEMBERS

    options: {
      bFooterShowGraphTable: true,
      gridControl: null,
      pContent: null,
      pContentJQ: null,
      pFooter: null,
      pFooterJQ: null,
      maxRowsFullCSV: 20000,
      maxRowsLimit: 30000,
      widgetCommand: 'records_graph',
      positions: {},
      splitter: null,
      prevSplitterPosition: 0,
      splitterPosition: 0,
      screenSplitterRatio: 0,
      colorDictionary: {
        green: '#006568',
        lightOrange: '#FF6F01',
        blue: '#90CAF9',
        orange: '#FFA500',
        yellow: '#FED000',
        lightBlue: '#D5E8FD',
        lightRed: '#FF2643',
        darkRed: '#8B0000',
        gray: '#808080',
        black: '#000000',
      },
      filterData: null,
      graphFilterApplied: false,
      splitterFullScreenValue: 23,
    },

    _templates: {
      currentWidget:
        ' \
						<span class="pvtBtnMinAxis shell_item_button showHeader-pivot-config ui-button ui-widget ui-state-default ui-corner-all ui-button-text-icon-primary"><a name="showHeader-pivot-config" class="showHeader-pivot-config ui-button-icon-primary ui-icon ui-icon-arrowthick-1-nw" title="Show/Hide header">&nbsp;</a></span>\
                        <div class="footer_text pivot_footer unselectable graph" style="display:block"> \
							<div class="footer_head">\
								<div class="indicator"></div>\
							</div> \
							<div class="footer_shell">\
								    <span class="shell_item_button save-graph-config ui-button ui-widget ui-state-default ui-corner-all ui-button-text-icon-primary"><a name="save-graph-config" class="ui-button-icon-primary ui-icon  ui-icon-disk save-graph-config" title="Click to save positions">&nbsp;</a></span>\
									<span class="shell_item_button discard-graph-config ui-button ui-widget ui-state-default ui-corner-all ui-button-text-icon-primary"><a name="discard-graph-config" class="ui-button-icon-primary ui-icon ui-icon-trash" title="Click to delete selected item">&nbsp;</a></span>\
									<span class="shell_item_button ui-button new-graph-config ui-widget ui-state-default ui-corner-all ui-button-text-icon-primary"><a name="new-graph-config" class="ui-button-icon-primary ui-icon ui-icon-plusthick" title="Click to save as new item">&nbsp;</a></span>\
									<span class="shell_item new-pivot-name"><input class="new-pivot-name" name="newGraphConfigName" type="text" min="3" max="50"/></span>\
							</div>\
							<div class="footer_command">\
                            <span class="pvtBtnMinAxis shell_item_button showHeader-pivot-config ui-button ui-widget ui-state-default ui-corner-all ui-button-text-icon-primary expandBtn" id="expandBtn"><a name="expand-graph-config" class="expand-graph-config ui-button-icon-primary ui-icon ui-icon-arrow-4-diag"title="Enter full screen">&nbsp;</a></span>\
                            </div>\
						</div> \
						<div class="pivot_content unselectable"  style="overflow: hidden;">\
								<div class="graph_body pvtFixedHeaderOuterContainer"><div class="ctx-menu"><ul class="ctx-menu-options">\
                                    <li class="ctx-menu-option" id="toggleLeafNodes">Toggle Nodes</li>\
                                    <li class="ctx-menu-option" id="centerGraph">Center Graph</li>\
                                    <li class="ctx-menu-option" id="filterByTickets" style="display: none;">Filter by tickets</li>\
                                    <li class="ctx-menu-option" id="filterByStatus" style="display: none;">Filter by status</li>\
                                    </ul>\
                            </div><div id="cy" class="cyWidget cyWorkflowAnimation"></div> </div> \
                            </div>',
      footerActions: {
        graphItem:
          '<span class="shell_item"><a class="ui-icon ui-icon-closethick" title="Close graph" href="javascript:;"></a></span>',
      },
    },

    contextMenuOptions: {
      menuVariables: {
        ctxMenu: null,
        togglenodes: null,
        centergraph: null,
        menuVisible: false,
      },

      toggleMenu: function (command) {
        this.menuVariables.ctxMenu.style.display =
          command === 'show' ? 'block' : 'none';
        if (command === 'show') this.menuVariables.menuVisible = true;
        else this.menuVariables.menuVisible = false;
      },

      setPosition: function (top, left) {
        this.menuVariables.ctxMenu = document.querySelector('.ctx-menu');
        this.menuVariables.ctxMenu.style.left = left + 'px';
        this.menuVariables.ctxMenu.style.top = top + 'px';
        this.toggleMenu('show');
      },

      toggleIsolatedNodes: function () {
        var isolatedNodes = cy.elements(cy.$('.isolated')).nodes();

        try {
          if (
            isolatedNodes[0] !== undefined &&
            isolatedNodes[0].css('display') !== 'none'
          ) {
            // debugger;

            isolatedNodes.forEach((node) => {
              node.style('display', 'none');
            });

            //setTimeout(function() { Array.from(document.querySelectorAll('.cy-ticketInStatusLabel.isolated')).forEach(element => element.style.display = "none") }, 5);
          } else {
            // Array.from(document.querySelectorAll('.cy-ticketInStatusLabel.isolated')).forEach(element => element.style.display = "block")

            isolatedNodes.forEach((node) => {
              node.style('display', 'element');
            });

            //cy.fit();
          }
        } catch (ex) {
          //console.log('Toggle nodes exception', ex.message);
          mdtLogger.error('mdt-cyWidget - toggle nodes', ex.message);
        }

        if (Object.keys(cy) > 0) {
          cy.center();
        }
        //cy.fit();
      },

      displayClassicContextMenu: function (e, renderedPosition) {
        document.querySelector('#filterByTickets').style.display = 'none';
        document.querySelector('#filterByStatus').style.display = 'none';
        document.querySelector('#toggleLeafNodes').style.display = 'block';
        document.querySelector('#centerGraph').style.display = 'block';
        e.preventDefault();

        const left = renderedPosition.x;
        const top = renderedPosition.y;

        this.setPosition(top, left);
        return false;
      },

      displayCustomContextMenu: function (selector, e, renderedPosition) {
        document.querySelector('#toggleLeafNodes').style.display = 'none';
        document.querySelector('#centerGraph').style.display = 'none';

        if (selector === 'edge') {
          document.querySelector('#filterByStatus').style.display = 'none';
          document.querySelector('#filterByTickets').style.display = 'block';
        } else {
          document.querySelector('#filterByStatus').style.display = 'block';
          document.querySelector('#filterByTickets').style.display = 'none';
        }

        e.preventDefault();

        const left = renderedPosition.x;
        const top = renderedPosition.y;

        this.setPosition(top, left);
        return false;
      },
    },

    _configStateCode: {
      Default: 1,
      AddNewItem: 2,
    },

    _configState: void 0,

    //#endregion

    //#region METHODS

    centerGraph: function () {
      cy = window.cy || {};
      if (Object.keys(cy).length > 0) {
        cy.center();
        cy.fit();
      }
      //cy.zoom(1);
    },

    checkedSize: function () {
      if (
        this.options.gridControl.options.gridModel.records >
        this.options.maxRowsLimit
      ) {
        mdt.notifyUser(
          'The size limit was exceeded (#' +
            this.options.maxRowsLimit +
            ' records).',
          2,
          5000
        );
        return false;
      }

      this.options.isLimitedMode =
        this.options.gridControl.options.gridModel.records >
        this.options.maxRowsFullCSV;

      return true;
    },

    //chooseShape: function(cy) {

    //     cy.elements().remove();

    //     var shapeList = ['ellipse',
    //         'triangle', 'round-triangle', 'rectangle', 'round-rectangle', 'bottom-round-rectangle', 'cut-rectangle', 'barrel', 'rhomboid', 'diamond',
    //         'round-diamond', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon',
    //         'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'star', 'tag', 'round-tag', 'vee'
    //     ]

    //     for (var i = 0; i < shapeList.length; i++) {
    //         cy.add([{
    //                 group: "nodes",
    //                 data: {
    //                     id: i,
    //                     label: `${i} \n  Shape test`
    //                 },
    //                 position: {
    //                     x: (i > 12) ? 350 : 180,
    //                     y: (i > 12) ? 70 * (i - 10) : 70 * (i + 2)

    //                 }

    //             }])
    //             .css({
    //                 'background-color': 'orange',
    //                 'color': `black' `

    //             })
    //         cy.nodes()[i].style("shape", shapeList[i]);
    //     }

    // },

    _confirm: function (message, fnTrue) {
      if (this._confirmDialog) {
        this._confirmDialog.remove();
        this._confirmDialog = null;
      }

      var self = this;
      this._confirmDialog = $('<div/>')
        .appendTo(this.element)
        .layoutConfirm({
          header: '<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;' + message,
          onClose: function (bConfirm) {
            self._confirmDialog.remove();
            self._confirmDialog = null;

            if (bConfirm === true && fnTrue) fnTrue.call(self, true);
          },
        });
    },

    _create: function () {
      this._super();
      return this;
    },

    _destroy: function () {
      this.options.splitter.destroy();
      this.options.splitter = null;
      this._super();
    },

    filterByStatus: function () {
      var filters = {};
      try {
        if (
          this.options.filterData &&
          typeof this.options.filterData !== 'undefined'
        ) {
          filters['Status'] = statusNodes.find(
            (statusNode) => statusNode.ID == this.options.filterData.data.id
          ).Name;
          var value = this.options.filterData.data.ticketsInStatus;
          if (typeof filters != 'undefined' && value > 0)
            this.updateGridFilters(filters);
          else mdt.notifyUser('No records found!', 2, 1000);
        }
      } catch (ex) {
        mdtLogger.error('mdt-cyWidget - filter by status', ex.message);
      }
    },

    filterByTickets: function () {
      var filters = {};
      try {
        if (
          this.options.filterData &&
          typeof this.options.filterData !== 'undefined'
        ) {
          filters['ID'] = this.options.filterData.data.ids;
          var value = this.options.filterData.data.ids.length;
          if (typeof filters != 'undefined' && value > 0)
            this.updateGridFilters(filters);
          else mdt.notifyUser('No records found!', 2, 1000);
        }
      } catch (ex) {
        mdtLogger.error('mdt-cyWidget - filter by tickets', ex.message);
      }
    },

    formatRgb: function (value) {
      if (value !== undefined)
        return 'rgb(' + value.r + ',' + value.g + ',' + value.b + ')';
    },

    generateEdges: async function (ticketsEdges) {
      var edges = [];
      var ok;

      edges[0] = {
        source: ticketsEdges[0][0].source,
        target: ticketsEdges[0][0].target,
        count: 0,
      };

      Object.values(ticketsEdges).map((entry) => {
        ok = 0;

        for (let j = 0; j < entry.length; j++)
          for (let i = 0; i < edges.length; i++) {
            if (
              edges[i].source == entry[j].source &&
              edges[i].target == entry[j].target
            ) {
              edges[i].count++;
              break;
            }

            if (i == edges.length - 1) {
              var tempObj = entry[j];
              tempObj.count = 1;
              edges[i + 1] = tempObj;
              i = edges.length;
            }
          }
      });

      return edges;
    },

    generateEdgesByActions: async function (ticketsEdges) {
      var edges = [];
      var ok;

      edges[0] = {
        source: ticketsEdges[Object.keys(ticketsEdges)[0]][0].source,
        target: ticketsEdges[Object.keys(ticketsEdges)[0]][0].target,
        action: ticketsEdges[Object.keys(ticketsEdges)[0]][0].action,
        count: 0,
        ticketIDs: [],
      };

      var edgesArray = [];
      Object.keys(ticketsEdges).forEach((key) => {
        edgesArray = edgesArray.concat(ticketsEdges[key]);
      });

      //debugger;

      Object.keys(ticketsEdges).map((key) => {
        var entry = ticketsEdges[key];
        ok = 0;

        for (let j = 0; j < entry.length; j++)
          for (let i = 0; i < edges.length; i++) {
            if (
              edges[i].source == entry[j].source &&
              edges[i].target == entry[j].target &&
              edges[i].action == entry[j].action
            ) {
              edges[i].count++;
              edges[i].ticketIDs.push(key);
              break;
            }

            if (i == edges.length - 1) {
              //debugger;
              var tempObj = entry[j];
              tempObj.count = 1;
              edges[i + 1] = tempObj;
              if (typeof edges[i + 1].ticketIDs == 'undefined')
                edges[i + 1].ticketIDs = [];
              edges[i + 1].ticketIDs.push(key);
              i = edges.length;
            }
          }
      });

      return edges;
    },

    _getSavedPivot: function (pivot_id, bShowWarn) {
      var piv;
      for (
        var i = 0, len = this.options.saved_list_graphs.length;
        i < len;
        i++
      ) {
        var flt = this.options.saved_list_graphs[i];
        if (flt['id'] == pivot_id) {
          piv = flt;
          break;
        }
      }
      if (!piv && bShowWarn !== false)
        mdt.notifyUser('Could not find saved pivot settings.', 2);
      return piv;
    },

    hexToRgb: function (hex) {
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : null;
    },

    _init: function () {
      this._initOptions();
      this._initHtml();
      return this;
    },

    _initContextMenu: function () {
      this.contextMenuOptions.menuVariables.ctxMenu =
        document.querySelector('.ctx-menu');
      this.contextMenuOptions.menuVariables.togglenodes =
        document.querySelector('#toggleLeafNodes');
      this.contextMenuOptions.menuVariables.centergraph =
        document.querySelector('#centerGraph');

      this.contextMenuOptions.menuVariables.togglenodes.addEventListener(
        'click',
        this.contextMenuOptions.toggleIsolatedNodes
      );
      this.contextMenuOptions.menuVariables.centergraph.addEventListener(
        'click',
        this.centerGraph
      );

      var self = this;

      $('#filterByStatus')
        .off()
        .on('click', function () {
          try {
            self.filterByStatus().call(self);
          } catch (ex) {
            mdtLogger.error(this, 'Filter Method Binding', ex.message);
          }
        });

      $('#filterByTickets')
        .off()
        .on('click', function () {
          try {
            self.filterByTickets().call(self);
          } catch (ex) {
            mdtLogger.error(this, 'Filter Method Binding', ex.message);
          }
        });
    },

    _initFooter: function () {
      if (!this._isAlive()) return;

      var self = this;

      this._controls = {
        pivot_body: $('.graph_body', this.options.pContentJQ), // aici trebuie modificat si pus graph-ul
        footer_head: $('.footer_head', this.options.pFooterJQ),
        footer_shell: $('.footer_shell', this.options.pFooterJQ),
        footer_command: $('.footer_command', this.options.pFooterJQ),
      };

      // graph command
      if (
        this.options.bFooterShowGraphTable &&
        this.options.gridControl != null
      ) {
        $(this._templates.footerActions.graphItem)
          .appendTo(this._controls.footer_command)
          .find('a.ui-icon-closethick')
          .on('click', self, self.ShowGridEvent);
      }

      // $('<button class="pvtBtnMinAxis"/>').appendTo(this.element).button({icons: {primary: "ui-icon-arrowthick-1-nw"}})
      $(this.element)
        .find('a.showHeader-pivot-config')
        .on('click', function (event) {
          //var $btn = $(this);
          self.options.headerMinimised = !self.options.headerMinimised;
          self.showMinimisedButton.apply(self);
          self._resizeWidget.call(self, event);
        });

      $(this.element)
        .find('a.expand-graph-config')
        .on('click', function (event) {
          //var $btn = $(this);
          if (typeof self.options.graphExpanded === 'undefined') {
            self.options.graphExpanded = false;
          }
          if (typeof self.options.splitterPosition === 'undefined')
            self.options.splitterPosition = self.options.splitter.position();
          if (
            self.options.splitterPosition <=
              self.options.splitterFullScreenValue &&
            self.options.splitterPosition != 0
          ) {
            self.options.graphExpanded = true;
          }
          // self.options.graphExpanded = !self.options.graphExpanded;
          try {
            if (self.options.graphExpanded) {
              if (
                self.options.prevSplitterPosition >=
                self.options.splitterFullScreenValue
              )
                self.options.splitter.position(
                  self.options.prevSplitterPosition
                );
              else {
                self.options.splitter.position('50%');
                self.options.splitterPosition =
                  self.options.splitter.position();
              }
            } else {
              self.options.splitterPosition = self.options.splitter.position();

              if (
                self.options.splitterPosition >=
                self.options.splitterFullScreenValue
              ) {
                self.options.splitter.position('0%');
              } else {
                self.options.splitter.position('50%');
                self.options.splitterPosition =
                  self.options.splitter.position();
              }
            }
            self._resizeWidget.call(self, event);
            self.options.graphExpanded = !self.options.graphExpanded;
          } catch (ex) {
            mdtLogger.error('Expand Graph Widget', ex.message);
          }
          setTimeout(function () {
            self.centerGraph();
          }, 150);
        });
    },

    _initGraph: function (currentID, saved_list_graphs) {
      //debugger;
      this._updateSavedConfigs(currentID, saved_list_graphs);
      //this._request(null, { 'widgetCommand': this.options.widgetCommand });
    },

    _initHtml: function () {
      this._initHTMLBody();
      this._initHTMLPointers();
      this._initFooter();
      // this._initGraph();
      this._initWidgets();
      this._initContextMenu();
    },

    _initHTMLBody: function () {
      $(this._templates.currentWidget).appendTo(this.element);
    },

    _initHTMLPointers: function () {
      this.options.pContentJQ = $('.pivot_content', this.element);
      if (this.options.pContentJQ.length == 1) {
        this.options.pContent = this.options.pContentJQ[0];
      }

      this.options.pFooterJQ = $('.pivot_footer', this.element);
      if (this.options.pFooterJQ.length == 1) {
        this.options.pFooter = this.options.pFooterJQ[0];
      }
    },

    _initOptions: function () {
      this.options.widgetRequest =
        this.options.gridControl.options.widgetRequest; // same widgetRequest with Grid
      this.options.widgetHeaderObj =
        this.options.gridControl.options.widgetHeaderObj; //			--//--

      if (this.options.gridControl != null && this.options.splitter == null) {
        var self = this;
        var positionPx =
          typeof this.options.gridControl.options.splitterPosition ===
          'undefined'
            ? '50%'
            : this.options.gridControl.options.splitterPosition;
        this.options.splitter =
          this.options.gridControl.options.gControlsJQ.split({
            orientation: 'vertical',
            limit: 20,
            position: positionPx,
            onDragEnd: function (event) {
              self._resizeWidget(event);
            },
          });
        //this.options.gridControl.hide();
        this.show();
      }
    },

    _initWidgets: function () {
      var self = this;
      this._request(null, { widgetCommand: 'graph-get-savedlist' });
      // debugger;
      //   this._updateSavedConfigs(
      //     this.options.gridControl.options.last_pivot_id,
      //     this.options.gridControl.options.saved_list_graphs
      //   );
    },

    lightOrDark: function (color) {
      // Variables for red, green, blue values
      var r, g, b, hsp;

      // Check the format of the color, HEX or RGB?
      try {
        if (color.match(/^rgb/)) {
          // If RGB --> store the red, green, blue values in separate variables
          color = color.match(
            /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/
          );

          r = color[1];
          g = color[2];
          b = color[3];
        } else {
          // If hex --> Convert it to RGB: http://gist.github.com/983661
          color = +(
            '0x' + color.slice(1).replace(color.length < 5 && /./g, '$&$&')
          );

          r = color >> 16;
          g = (color >> 8) & 255;
          b = color & 255;
        }
      } catch (ex) {
        //console.log('Exception', ex.message);
        mdtLogger.error(this, 'Inner color', ex.message);
      }

      // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
      hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

      // Using the HSP value, determine whether the color is light or dark
      if (hsp > 165) {
        return 1; //light
      } else {
        return 0; //dark
      }
    },

    // mapTicketsToStates: async function(gridHead, tickets) {

    //     var ticketsStates = {};
    //     var idIndex = gridHead.indexOf("TicketID");
    //     var statusIndex = gridHead.indexOf("StatusID");
    //     var ticketsPerStatus = {};

    //     tickets.forEach(function(ticket) {
    //         if (ticketsPerStatus.hasOwnProperty(ticket[statusIndex]))
    //             ticketsPerStatus[ticket[statusIndex]] += 1;
    //         else
    //             ticketsPerStatus[ticket[statusIndex]] = 1;

    //         if (ticketsStates.hasOwnProperty(ticket[idIndex])) {
    //             var states = ticketsStates[ticket[idIndex]];
    //             states.push(ticket[statusIndex]);
    //             ticketsStates[ticket[idIndex]] = states;
    //         } else {

    //             var states = [];
    //             states.push(ticket[statusIndex]);
    //             ticketsStates[ticket[idIndex]] = states;

    //         }

    //     });

    //     return [ticketsStates, ticketsPerStatus];

    // },

    mapTicketsToStatesAndActions: async function (gridHead, tickets) {
      //debugger;

      var ticketsStates = {};
      var previousActionIndex = gridHead.indexOf('ActionID');
      var idIndex = gridHead.indexOf('TicketID');
      var statusIndex = gridHead.indexOf('StatusID');
      var nextActionIndex = gridHead.indexOf('NextActionID');
      var nextStatusIndex = gridHead.indexOf('NextStatusID');
      var ticketsPerStatus = {};

      tickets.forEach(function (ticket) {
        if (ticketsPerStatus.hasOwnProperty(ticket[statusIndex]))
          ticketsPerStatus[ticket[statusIndex]] += 1;
        else ticketsPerStatus[ticket[statusIndex]] = 1;

        var transition = {};

        transition['previousActionID'] = ticket[previousActionIndex];
        transition['firstStatusID'] = ticket[statusIndex];
        transition['nextActionID'] = ticket[nextActionIndex];
        transition['nextStatusID'] = ticket[nextStatusIndex];

        if (ticketsStates.hasOwnProperty(ticket[idIndex])) {
          var transitions = ticketsStates[ticket[idIndex]];
          if (transition['nextStatusID'] !== null) {
            transitions.push(transition);
            ticketsStates[ticket[idIndex]] = transitions;
          }
        } else {
          var transitions = [];
          transitions.push(transition);
          ticketsStates[ticket[idIndex]] = transitions;
        }
      });

      return [ticketsStates, ticketsPerStatus];
    },

    // mapTicketsStatesToEdges: async function(ticketsStates) {
    //     return Object.entries(ticketsStates).map(function(entry) {
    //         var edgesList = [];
    //         for (let i = 0; i < entry[1].length - 1; i++) edgesList.push({
    //             'source': entry[1][i],
    //             'target': entry[1][i + 1]
    //         });
    //         return edgesList;
    //     })

    // },

    mapTicketsStatesAndActionsToEdges: async function (
      ticketsStates,
      virtualNodeId
    ) {
      var resultEdges = {};

      Object.entries(ticketsStates).map(function (entry, index) {
        var edgesList = [];
        for (let i = 0; i <= entry[1].length; i++) {
          if (
            entry[1][i - 1] !== undefined &&
            (entry[1][i + 1] === undefined ||
              entry[1][i].previousActionID === entry[1][i - 1].nextActionID)
          )
            try {
              edgesList.push({
                source: entry[1][i - 1].firstStatusID,
                target: entry[1][i - 1].nextStatusID,
                action: entry[1][i - 1].nextActionID,
              });
            } catch (ex) {
              //console.log('Exception in mapping to edges', ex.message)
              mdtLogger.error('mdt-cyWidget - mapping edges', ex.message);
            }
          else {
            try {
              edgesList.push({
                source: virtualNodeId,
                target: entry[1][i].firstStatusID,
                action: entry[1][i].previousActionID,
              });
            } catch (ex) {
              //console.log('Exception in mapping to edges', ex.message)
              mdtLogger.error('mdt-cyWidget - mapping edges', ex.message);
            }
          }
        }
        resultEdges[entry[0]] = edgesList;
      });

      return resultEdges;
    },

    _onSavedConfigsClick: function ($e) {
      //debugger;
      var self = this;
      var command = $('a', $e).attr('name');
      var requestFn = this.options.gridControl._request;
      var request, header, configName;

      switch (command) {
        case 'save-graph-config':
          var graphUIOptions = self.savePositions();

          request = {
            CategoryID: 'grid_pivot',
            ConfigValue: graphUIOptions,
          };

          header = { widgetCommand: 'save-graph-config' };

          if (this._configState === this._configStateCode.AddNewItem) {
            configName = $.trim(
              $('input.new-pivot-name', this._controls.footer_shell).val()
            );

            if (configName === '') {
              mdt.notifyUser('Please enter a graph config name.', 2);
              $('input.new-pivot-name', this._controls.footer_shell).focus();
              return;
            }

            // set config name
            request['ConfigName'] = configName;

            var bExists = false;
            if (this.options.saved_list_graphs) {
              for (
                var i = 0, len = this.options.saved_list_graphs.length;
                i < len;
                i++
              ) {
                var flt = this.options.saved_list_graphs[i];
                if (flt['name'] == configName) {
                  bExists = true;
                  break;
                }
              }
            }

            if (bExists === true) {
              this._confirm(
                'Config name allready exists.</br> Overwrite ?',
                function () {
                  requestFn.call(this.options.gridControl, request, header);
                }
              );
            } else requestFn.call(this.options.gridControl, request, header);
          } else {
            var selectVal = Math.round(this.options.selectPivotObj.val());
            if (selectVal <= 0) {
              mdt.notifyUser(
                'Please select graph config that you want to save as.',
                2
              );
              return;
            }

            var piv = this._getSavedPivot(selectVal);
            if (!piv) return;

            request['ConfigID'] = selectVal;
            request['ConfigName'] = piv['name'];

            this._confirm('Overwrite selected config settings ?', function () {
              requestFn.call(this.options.gridControl, request, header);
            });
          }
          break;
        case 'discard-graph-config':
          if (this._configState === this._configStateCode.AddNewItem) {
            $('.new-pivot-name', this._controls.footer_shell).val('');
            this._updateSavedConfigsState(this._configStateCode.Default);
          } else {
            var selectVal = Math.round(this.options.selectPivotObj.val());
            if (selectVal <= 0) {
              mdt.notifyUser(
                'Please select graph config that you want to delete.',
                2
              );
              return;
            }

            this._confirm('Delete selected settings ?', function () {
              var piv = this._getSavedPivot(selectVal);
              if (!piv) return;

              request = {
                CategoryID: 'grid_pivot',
                ConfigID: selectVal,
                ConfigName: piv['name'],
              };
              header = { widgetCommand: 'delete-graph-config' };

              requestFn.call(this.options.gridControl, request, header);
            });
          }
          break;
        case 'new-graph-config':
          this._updateSavedConfigsState(this._configStateCode.AddNewItem);
          break;
      }
    },

    updateGridFilters: function (filters) {
      if (!this.options.graphFilterApplied) {
        this.options.gridControl.options.gridModel.prevFiltersVal =
          Object.assign(
            {},
            this.options.gridControl.options.gridModel.filtersVal
          );
        this.options.graphFilterApplied = true;
      }

      this.options.gridControl.options.gridModel.filtersVal = Object.assign(
        {},
        this.options.defaultFilters
      );

      if (this.options.gridControl.options.gridModel.filtersVal == null)
        this.options.gridControl.options.gridModel.filtersVal = {};

      if (filters != null) {
        for (var label in filters) {
          var field = null;
          this.options.gridControl.options.gridModel.filters.forEach(function (
            filter
          ) {
            if (filter.label == label) field = filter.field;
          });
          if (field != null) {
            if (filters[label] == 'null')
              this.options.gridControl.options.gridModel.filtersVal[field] = {
                filter: '9',
              };
            else if (label === 'Status')
              this.options.gridControl.options.gridModel.filtersVal[field] = {
                filter: '3',
                val1: filters[label],
              };
            else if (label === 'ID')
              this.options.gridControl.options.gridModel.filtersVal[field] = {
                filter: '99',
                val1: filters[label],
                val2: filters[label].join(','),
              };
          }
        }
      }

      this.options.gridControl.options.gridModel.page = 0;
      this.options.gridControl.options.MCIC_autoUpdateField = null;
      this.options.gridControl.options.graphGridFilterApplied = true;
      this.options.gridControl.gridFilterNone();
      this.options.gridControl.GridReset(false);
    },

    refresh: function () {
      mdt.log('mdt.cyWidget - refresh');
      if (this.options.splitter.position() == this.options.splitter.width())
        this.options.splitter.position('50%');
      this.updateDefaultFilters();
      try {
        if (this.options.selectPivotObj !== undefined) {
          this._createControl.select(this.options.selectPivotObj.parent());

          if ($('input.new-pivot-name').length == 0) {
            $('.new-pivot-name').append(
              '<input class="new-pivot-name" name="newGraphConfigName" type="text" min="3" max="50"/>'
            );
          }
        }
      } catch (ex) {
        mdtLogger.error('cyWidget-refresh', ex.message);
      }
      //debugger;

      this._request(null, { widgetCommand: this.options.widgetCommand });
    },

    _request: function (request, header, async, callback) {
      if (!this._isAlive()) return;

      switch (header['widgetCommand']) {
        case 'records_graph':
          if (!this.checkedSize()) {
            this.ShowGrid();
            return;
          }

          var gridControl = this.options.gridControl;
          var gridSearch = null;
          if (
            gridControl.options.gridSearchMode === 'search' &&
            gridControl.options.bFooterShowSearch === true &&
            isDefined(gridControl.options.searchWidget)
          ) {
            gridSearch =
              gridControl.options.searchWidget.searchBoxWidget('value');
            //gridControl.options.gridSearchText = gridSearch.search;
            // no search if no value
            if (isDefined(gridSearch.search) && gridSearch.search == '')
              gridSearch = null;
          }

          //if (this.options.isLimitedMode) ....

          var reqObj = {
            page: gridControl.options.gridModel.page,
            offset: 0,
            sort: gridControl.options.gridModel.sort.column,
            order: gridControl.options.gridModel.sort.order,
            gridAutoUpdate: false,
            gridSearch: JSON.stringify(gridSearch),
            headRecords: 1,
          };

          try {
            var otherRequestParam = gridControl.options.otherRequestParam;
            if (
              otherRequestParam != null &&
              typeof otherRequestParam == TYPE_OBJECT
            ) {
              for (var key in otherRequestParam) {
                reqObj[key] = otherRequestParam[key];
              }
            }
          } catch (ex) {}

          if (gridControl.options.gridModel.filtersVal != null) {
            reqObj['filters'] = gridControl.options.gridModel.filtersVal;
          }

          reqObj['bOnlyFilterData'] = !gridControl.options.bOnlyFilterData
            ? 0
            : 1;
          reqObj['hasFilters'] =
            gridControl.options.gridModel.filtersVal == null ? 0 : 1;

          this._super(reqObj, { widgetCommand: this.options.widgetCommand });

          reqObj = null;
          break;
        default:
          this._super(request, header, async, callback);
          break;
      }
    },

    _resizeWidget: function (evt) {
      $('.pivot_content').css('visibility', 'visible');

      this.centerGraph();
      var self = this;
      this._super(evt);

      if (typeof evt === 'undefined') {
        if (
          this.options.screenSplitterRatio > 0.8 &&
          this.options.widgetWidth > 0
        ) {
          this.options.splitter.position('100%');
          $('.pivot_content').css('visibility', 'hidden');
          try {
            $(
              'a.grid_graph_refresh',
              this.options.gridControl._controls.footer_command
            )
              .removeClass('grid_graph_refresh')
              .addClass('grid_graph');
          } catch (ex) {
            mdtLogger.error(this, 'Resize', ex.message);
          }
        } else {
          if (this.options.screenSplitterRatio < 0.1) {
            this.options.screenSplitterRatio =
              this.options.splitter.position() / $('.layout-content').width();
          }
          $('.pivot_content').css('visibility', 'visible');
          try {
            $('a.grid_graph', this.options.gridControl._controls.footer_command)
              .removeClass('grid_graph')
              .addClass('grid_graph_refresh');
            this.options.prevSplitterPosition = this.options.splitterPosition;
            this.options.splitterPosition =
              this.options.screenSplitterRatio * $('.layout-content').width();
            this.options.splitter.position(this.options.splitterPosition);
          } catch (ex) {
            mdtLogger.error(this, 'Resize', ex.message);
          }
          setTimeout(function () {
            self.centerGraph();
          }, 150);
        }
        //}
      } else {
        if (this.options.widgetWidth < 100) {
          $('.pivot_content').css('visibility', 'hidden');
          this.options.splitter.position('100%');
          try {
            $(
              'a.grid_graph_refresh',
              this.options.gridControl._controls.footer_command
            )
              .removeClass('grid_graph_refresh')
              .addClass('grid_graph');
          } catch (ex) {
            mdtLogger.error(this, 'Resize', ex.message);
          }
        } else {
          $('.pivot_content').css('visibility', 'visible');
          try {
            $('a.grid_graph', this.options.gridControl._controls.footer_command)
              .removeClass('grid_graph')
              .addClass('grid_graph_refresh');
          } catch (ex) {
            mdtLogger.error(this, 'Resize', ex.message);
          }
          setTimeout(function () {
            self.centerGraph();
          }, 150);
        }
        this.options.prevSplitterPosition = this.options.splitterPosition;
        this.options.splitterPosition = this.options.splitter.position();
      }

      if (this.options.splitterPosition == 0)
        this.options.splitterPosition = this.options.splitter.position();

      if (this.options.prevSplitterPosition == 0)
        this.options.prevSplitterPosition = this.options.splitter.position();

      try {
        this.options.screenSplitterRatio =
          this.options.splitterPosition / $('.layout-content').width();
      } catch (ex) {
        mdtLogger.error(this, 'Screen Splitter Ratio', ex.message);
      }

      this.options.gridControl.options.splitterPosition =
        this.options.splitter.position();

      mdt.log('mdt.cyWidget - _resizeWidget');
      mdt.log('mdt.cyWidget - widgetWidth:' + this.options.widgetWidth);
      mdt.log('mdt.cyWidget - widgetHeight:' + this.options.widgetHeight);

      //this._updateGraph(); // recreate pivot .... must change - c3.resize(...)
    },

    savePositions: function () {
      var positions = {};
      var toggled = false;

      cy.nodes().forEach((node) => {
        //if ((node._private.style.display === undefined) || (node._private.style.display.value === 'element'))
        positions[node._private.data.id] = {
          x: node._private.position.x,
          y: node._private.position.y,
        };
      });

      positions['toggled'] = toggled;

      for (let node of cy.nodes()) {
        try {
          if (
            node._private.style !== undefined &&
            node._private.style.display.value === 'none'
          ) {
            toggled = true;
            break;
          }
        } catch (e) {
          //console.log(e.message);
          mdtLogger.error('mdt.cyWidget - savePositions', e.message);
        }
      }
      positions['toggled'] = toggled;
      return JSON.stringify(positions);
    },

    setNewGraphPositions: function () {
      var self = this;

      try {
        if (cy.hasOwnProperty('_private')) {
          cy.nodes().forEach((node) => {
            if (self.options.positions.hasOwnProperty(node._private.data.id)) {
              cy.$(`#${node._private.data.id}`).style('display', 'element');
              cy.$(`#${node._private.data.id}`).position({
                x: self.options.positions[node._private.data.id].x,
                y: self.options.positions[node._private.data.id].y,
              });
            }
          });

          var toggled = false;

          if (self.options.positions.hasOwnProperty('toggled')) {
            toggled = self.options.positions['toggled'];
          }
          if (toggled) {
            self.contextMenuOptions.toggleIsolatedNodes();
          }
          // var layout = cy.layout({
          //     name: 'preset',
          //     convergenceThreshold: 100,
          //     animate: true,
          //     avoidOverlap: false,
          //     circle: false,
          //     animationDuration: 500,
          //     condense: false,
          //     fit: true,
          //     padding: 100
          // });

          // layout.run();

          cy.animate(
            {
              pan: { x: 20, y: 20 },
              zoom: 1,
              fit: {
                eles: cy.elements(),
              },
            },
            {
              duration: 700,
            }
          );
        }
      } catch (e) {
        mdtLogger.error('mdt.cyWidget - nodes not defined', e.message);
      }
    },

    _setSavedGraph: function (graph_id) {
      debugger;
      graph_id = Math.round(graph_id);
      if (isNaN(graph_id) || graph_id <= 0) return;
      //if (!this._currentRecords) return;

      this.options.last_pivot_id = graph_id;

      var graph = this._getSavedPivot(graph_id);
      if (graph) {
        this.options.last_pivot_Options = graph['value'];
      }

      this._updateGraph();
    },

    //#region GRAPH-SETUP

    setUpGraph: async function (
      currentStatuses,
      edges,
      ticketsPerStatus,
      currentActions
    ) {
      var self = this;
      var ctrlKeyDown = false;
      var ticketColors = {};

      $(window).click(function (e) {
        if (self.contextMenuOptions.menuVariables.menuVisible) {
          self.contextMenuOptions.toggleMenu('hide');
        }
      });

      $(window).keydown(function (event) {
        if (event.ctrlKey) ctrlKeyDown = true;
      });

      $(window).keyup(function (event) {
        ctrlKeyDown = false;
      });

      var cy = (window.cy = cytoscape({
        container: document.getElementById('cy'),
        autounselectify: false,
        boxSelectionEnabled: true,
        panningEnabled: true,
        selectionType: 'single',

        layout: {
          name: 'preset',
        },

        wheelSensitivity: 0.3,

        style: [
          {
            selector: 'node',
            css: {
              'background-color': '#ffffff',
              content: 'data(label)',
              'border-width': '1px',
              'border-color': 'black',
              'border-style': 'dashed',
              color: 'white',
              width: '155px',
              height: '50px',
              shape: 'round-rectangle',
              'text-halign': 'center',
              'text-valign': 'center',
              'text-wrap': 'wrap',
              'font-size': '15',
              'font-family':
                'Century Gothic,CenturyGothic,AppleGothic,sans-serif',
            },
          },
          {
            selector: 'edge',
            css: {
              content: 'data(label)',
              'edge-text-rotation': 'autorotate',
              // 'overlay-opacity': 0,
              'line-color': '#ff6f01',
              'text-wrap': 'wrap',
              'text-margin-y': '-1em',
              width: '4',
              'font-size': '16',
              'font-family':
                'Century Gothic,CenturyGothic,AppleGothic,sans-serif',
              'target-arrow-shape': 'vee',
              'target-arrow-color': '#3d3d3d',
              'arrow-scale': '2',
              'curve-style': 'bezier',
              // "control-point-distances": "20px 30px 40px",
              // "control-point-weights": "0.5 0.2 0.8",
              'control-point-step-size': '7em', //6 or more for self-edges to be properly drawn
            },
          },
          {
            selector: ':selected',
            style: {},
          },
        ],
      }));

      cy.userZoomingEnabled(true);

      var virtualNodes = [];

      cy.add([
        {
          group: 'nodes',
          data: {
            id: currentStatuses.length,
            label: 'Entry',
          },
          position: {
            x:
              this.options.positions[currentStatuses.length] !== undefined
                ? this.options.positions[currentStatuses.length].x
                : cy._private.container.scrollWidth / 3,
            y:
              this.options.positions[currentStatuses.length] !== undefined
                ? this.options.positions[currentStatuses.length].y
                : 0,
          },
        },
      ]).css({
        // 'visibility': 'hidden'
        'background-color': 'white',
        color: 'black',
      });

      //adding nodes dinamically

      statusNodes = currentStatuses || {};

      ticketColors[currentStatuses.length] = '#FFFFFF';

      for (var k = 0; k < Object.keys(statusNodes).length; k++) {
        try {
          var currentNode = Object.values(statusNodes)[k];
          ticketColors[currentNode.ID] = currentNode.Color;

          if (currentNode !== undefined) {
            if (
              this.options.positions[parseInt(currentNode.ID)] !== undefined
            ) {
              if (
                this.options.positions[parseInt(currentNode.ID)].x !==
                  undefined &&
                this.options.positions[parseInt(currentNode.ID)].y !== undefined
              ) {
                cy.add([
                  {
                    group: 'nodes',
                    data: {
                      id: parseInt(currentNode.ID),
                      // label: `${currentNode.Name} \n  Tickets: ${ticketsPerStatus[currentNode.ID] || 0}`
                      label: currentNode.Name + ' \n' + 'Tickets: ',
                    },
                    position: {
                      x: this.options.positions[parseInt(currentNode.ID)].x,
                      y: this.options.positions[parseInt(currentNode.ID)].y,
                    },
                  },
                ]).css({
                  'background-color': currentNode.Color,
                  color: `${
                    this.lightOrDark(currentNode.Color) ? 'black' : 'white'
                  }`,
                });
              }
            } else if (Object.keys(this.options.positions).length == 0) {
              cy.add([
                {
                  group: 'nodes',
                  data: {
                    id: parseInt(currentNode.ID),
                    label: currentNode.Name + ' \n' + 'Tickets: ',
                  },
                  position: {
                    x: 70 * (parseInt(currentNode.ID) + 2),
                    y: 70 * (parseInt(currentNode.ID) + 2),
                  },
                },
              ]).css({
                'background-color': currentNode.Color,
                color: `${
                  this.lightOrDark(currentNode.Color) ? 'black' : 'white'
                }`,
              });
            }
          }
        } catch (ex) {
          //console.log(ex);
          mdtLogger.error('mdt-cyWidget - adding nodes', ex.message);
        }
      }

      for (var k = 0; k < Object.keys(edges).length; k++) {
        if (currentActions !== undefined)
          var action = currentActions.filter(
            (action) => action.ID == Object.values(edges)[k].action
          );

        try {
          if (
            Object.values(edges)[k].source != null &&
            Object.values(edges)[k].target != null
          ) {
            cy.add([
              {
                group: 'edges',
                data: {
                  source: Object.values(edges)[k].source,
                  target: Object.values(edges)[k].target,
                  text: Object.values(edges)[k].count,
                  //label: `${Object.values(edges)[k].count} \n\n ${action[0].Name}`,
                  label: `${Object.values(edges)[k].count} ( ${
                    action[0] !== 'undefined' ? action[0].Name : ''
                  } )`,
                  ids: Object.values(edges)[k].ticketIDs,
                  type: 'bendpoint',
                },
              },
            ]);
          }
        } catch (ex) {
          //console.log(ex);
          mdtLogger.error('mdt-cyWidget - adding edges', ex.message);
        }
      }

      edges.forEach((edge) => {
        if (
          (edge.source === 0 && edge.target !== 0 && edge.target !== null) ||
          edge.target === null
        ) {
          var virtualNodeId = cy.nodes().length + virtualNodes.length;

          if (edge.target === null) {
            virtualNodes.push({
              id: virtualNodeId,
              source: edge.source,
              position: cy.nodes()[edge.source + 1]._private.position,
              count: edge.count,
            });
          } else {
            virtualNodes.push({
              id: virtualNodeId,
              target: edge.source,
              position: cy.nodes()[edge.source + 1]._private.position,
              count: edge.count,
            });
          }
        }
      });

      // virtualNodes.forEach(node => {
      //     cy.add([{
      //             group: "nodes",
      //             data: {
      //                 id: parseInt(node.id),
      //                 label: ``
      //             },
      //             position: {
      //                 x: node.position.x + (cy._private.container.scrollWidth / 5),
      //                 y: node.position.y - (cy._private.container.scrollHeight / 5)

      //             }

      //         }])
      //         .css({
      //             'visibility': 'hidden',

      //         });

      //     cy.add([{

      //         group: 'edges',
      //         data: {
      //             source: `${node.source!==undefined?node.source:node.id}`,
      //             target: `${node.target!==undefined?node.target:node.id}`,
      //             text: `${node.target!==undefined?node.count:0}`,
      //             label: `${node.count}`,
      //             type: 'bendpoint'
      //         }

      //     }])

      // });

      // compute tickets currently in each status

      try {
        cy.nodes().forEach((node) => {
          if (node.connectedEdges().length == 0) {
            node.addClass('isolated');
          }

          node._private.data.incomers =
            node._private.data.outgoers =
            node._private.data.ticketsInStatus =
              0;

          node.incomers('edge').forEach((incomer) => {
            node._private.data.incomers =
              parseInt(node._private.data.incomers) +
              parseInt(incomer._private.data.text);
          });

          node.outgoers('edge').forEach((outgoer) => {
            node._private.data.outgoers += parseInt(outgoer._private.data.text);
          });

          node._private.data.ticketsInStatus =
            node._private.data.incomers - node._private.data.outgoers || 0;

          if (node._private.data.id != currentStatuses.length)
            node._private.data.label += node._private.data.ticketsInStatus;
        });
      } catch (ex) {
        // console.log(ex);
        mdtLogger.error(
          'mdt-cyWidget - compute incomers and outgoers',
          ex.message
        );
      }

      cy.style().update();

      // debugger;

      //htmlLabel script added to work for both edges and nodes

      // cy.nodeHtmlLabel([{
      //         query: 'node',
      //         valign: "top",
      //         halign: "right",
      //         valignBox: "top",
      //         halignBox: "center",
      //         tpl: function(data) {
      //             return `<div id = "cy-ticketInStatusLabel${data.id}"
      //                                         class = "cy-ticketInStatusLabel ${((data.incomers == 0) && (data.outgoers == 0)) ? 'isolated' : ''}"
      //                                         style = "background-color:${(data.ticketsInStatus < 0) ? 'red' : ticketColors[data.id]}; color : ${self.lightOrDark(ticketColors[data.id]) ? 'black' : 'white'}" > Currently: ` + data.ticketsInStatus + '</div>';
      //         }
      //     },
      //     // {
      //     //     query: '.l2',
      //     //     tpl: function(data) {
      //     //         return '<p class="cy-title__p1">' + data.id + '</p>' + '<p  class="cy-title__p2">' + data.name + '</p>';
      //     //     }
      //     // }
      // ]);

      var selectedNodes = {};
      var selectedPredecessors = {};
      var ispredecessorsSelected = false;

      cy.on('click', function (event) {
        if ($.isEmptyObject(event.target._private.data)) {
          if (selectedNodes)
            for (var i = 0; i < selectedNodes.length; i++) {
              selectedNodes[i].style(
                'background-color',
                ticketColors[selectedNodes[i]._private.data.id]
              );
              selectedNodes[i].style(
                'color',
                self.lightOrDark(
                  ticketColors[selectedNodes[i]._private.data.id]
                )
                  ? 'black'
                  : 'white'
              );
            }

          if (ispredecessorsSelected) {
            selectedPredecessors['nodes'].forEach((predecessor) => {
              //if (predecessor._private.data.id != currentStatuses.length)
              predecessor.animate({
                style: {
                  backgroundColor: ticketColors[predecessor._private.data.id],
                  color: self.lightOrDark(
                    ticketColors[predecessor._private.data.id]
                  )
                    ? 'black'
                    : 'white',
                },
              });
            });

            selectedPredecessors['edges'].animate({
              style: { 'line-color': self.options.colorDictionary.lightOrange },
            });

            ispredecessorsSelected = false;
            isOneNodeSelected = false;
          }

          window['selectedNodes'] = {};
          selectedNodes = window['selectedNodes'];
        }
      });

      cy.on('click', 'node', function (event) {
        var node = event.target;

        //if (node._private.data.id != currentStatuses.length) {

        //console.log(node._private.data);

        if (!ctrlKeyDown) {
          window['selectedNodes'] = cy.$('node:selected');
          selectedNodes = window['selectedNodes'];
        }

        if (ispredecessorsSelected) {
          selectedPredecessors['nodes'].forEach((predecessor) => {
            // if (predecessor._private.data.id != currentStatuses.length)
            if (predecessor._private.data.id != node._private.data.id)
              predecessor.animate(
                {
                  style: {
                    backgroundColor: ticketColors[predecessor._private.data.id],
                    color: self.lightOrDark(
                      ticketColors[predecessor._private.data.id]
                    )
                      ? 'black'
                      : 'white',
                  },
                },
                { duration: 150 }
              );
          });
          selectedPredecessors['edges'].animate(
            {
              style: { 'line-color': self.options.colorDictionary.lightOrange },
            },
            { duration: 1 }
          );

          if (
            selectedPredecessors['currentNode']._private.data.id !==
            node._private.data.id
          ) {
            ispredecessorsSelected = false;
          }

          if (!ctrlKeyDown)
            selectedPredecessors['currentNode'].animate(
              {
                style: {
                  backgroundColor:
                    ticketColors[
                      selectedPredecessors['currentNode']._private.data.id
                    ],
                  color: self.lightOrDark(
                    ticketColors[
                      selectedPredecessors['currentNode']._private.data.id
                    ]
                  )
                    ? 'black'
                    : 'white',
                },
              },
              { duration: 50 }
            );
        }

        //console.log("Connected edges", this.connectedEdges())
        //console.log("Connected edges targets", this.connectedEdges().targets())
        //console.log("Successors", this.successors()) //successor nodes and edges including self edges
        //console.log("Successor targets", this.successors().targets()) //successor nodes only
        //console.log("Predecessors", this.predecessors().nodes())
        //console.log("Incomers", this.incomers())

        if (ispredecessorsSelected == false && !ctrlKeyDown) {
          selectedPredecessors['nodes'] = this.predecessors().nodes();
          selectedPredecessors['edges'] = this.predecessors().edges();
          selectedPredecessors['currentNode'] = node;
          selectedPredecessors['nodes'].forEach((predecessor) => {
            if (predecessor._private.data.id !== node._private.data.id)
              predecessor.animate(
                {
                  style: {
                    backgroundColor: self.options.colorDictionary.orange,
                    color: 'black',
                  },
                },
                { duration: 150 }
              );
          });
          selectedPredecessors['edges'].animate(
            { style: { 'line-color': self.options.colorDictionary.yellow } },
            { duration: 150 }
          );
          selectedPredecessors['currentNode'].animate(
            {
              style: {
                backgroundColor: self.options.colorDictionary.blue,
                color: 'black',
              },
            },
            { duration: 50 }
          );
          ispredecessorsSelected = true;
        }

        if (
          node._private.style['background-color'].strValue ==
          self.formatRgb(self.hexToRgb(self.options.colorDictionary.blue))
        ) {
          ispredecessorsSelected = false;
        }

        if (ctrlKeyDown) {
          for (var i = 0; i < selectedNodes.length; i++) {
            if (selectedNodes[i]._private.data.id == node._private.data.id) {
              selectedNodes[i].style(
                'background-color',
                ticketColors[selectedNodes[i]._private.data.id]
              );
              selectedNodes[i].style(
                'color',
                self.lightOrDark(
                  ticketColors[selectedNodes[i]._private.data.id]
                )
                  ? 'black'
                  : 'white'
              );
              cy.$('node:unselected').add(selectedNodes[i]);
              delete cy.$('node:selected')[i];
            }
          }
        }
        //}
      });

      cy.on('click', 'edge', function (event) {
        var edge = event.target;
        //console.log('Edge clicked: source:' + edge._private.data.source + ' \n target: ' + edge._private.data.target);
      });

      var elementCtxPressed = false;

      cy.on('cxttap', function (event) {
        if (event.target[0]) {
          if (['nodes', 'edges'].indexOf(event.target[0]._private.group) >= 0) {
            if (['edges'].indexOf(event.target[0]._private.group) >= 0) {
              elementCtxPressed = true;
              self.contextMenuOptions.displayCustomContextMenu(
                'edge',
                event.originalEvent,
                event.renderedPosition
              );
              self.options.filterData = event.target[0]._private;
            } else if (['nodes'].indexOf(event.target[0]._private.group) >= 0) {
              elementCtxPressed = true;
              if (event.target[0]._private.data.id != currentStatuses.length) {
                self.contextMenuOptions.displayCustomContextMenu(
                  'node',
                  event.originalEvent,
                  event.renderedPosition
                );
                self.options.filterData = event.target[0]._private;
              }
            }
          }
        } else {
          elementCtxPressed = false;
          self.contextMenuOptions.displayClassicContextMenu(
            event.originalEvent,
            event.renderedPosition
          );
        }
      });

      cy.on('layoutstop', function () {
        cy.maxZoom(1);
        cy.maxZoom(200);
        cy.fit();
      });

      cy.on('select', 'node', function (event) {
        window['selectedNodes'] = cy.$('node:selected');
        selectedNodes = window['selectedNodes'];
        for (var i = 0; i < selectedNodes.length; i++) {
          selectedNodes[i].style(
            'background-color',
            self.options.colorDictionary.blue
          );
          selectedNodes[i].style('color', 'black');
        }
      });

      cy.resize();

      var layout = cy.layout({
        name: 'preset',
        convergenceThreshold: 100,
        animate: false,
        avoidOverlap: false,
        circle: false,
        animationDuration: 500,
        condense: false,
        fit: true,
        padding: 100,
      });

      layout.run();
      cy.fit();
    },

    //#endregion

    ShowGrid: function () {
      //this.hide();
      //this.options.gridControl.show();
      this.options.splitter.position('100%');
      this.options.splitter.trigger('splitter.resize');

      try {
        $(
          'a.grid_graph_refresh',
          this.options.gridControl._controls.footer_command
        )
          .removeClass('grid_graph_refresh')
          .addClass('grid_graph');
        this.options.screenSplitterRatio =
          this.options.splitter.position() / $('.layout-content').width();
        this.options.splitterPosition = this.options.splitter.position();
      } catch (ex) {
        mdtLogger.error(this, 'ShowGrid', ex.message);
      }
    },

    ShowGridEvent: function (evt) {
      var self = evt.data;
      if (self.graphWidget !== 'undefined') self.graphWidget = null;
      //self._destroy();
      self.ShowGrid();
    },

    showMinimisedButton: function () {
      var $btn = $(this.element).find('a.showHeader-pivot-config');
      var $pivot = $btn.parents('.mcic_pivot');

      if (!this.options.headerMinimised) {
        $('.pvtControlsAxis, .pivot_footer', $pivot).show();
        $('.pivot_content', $pivot).css(
          'top',
          $('.pivot_footer', $pivot).css('height')
        );
        $btn.removeClass('ui-icon-arrowthick-1-se');
        $btn.addClass('ui-icon-arrowthick-1-nw');
      } else {
        $('.pvtControlsAxis, .pivot_footer', $pivot).hide();
        $('.pivot_content', $pivot).css('top', '0px');
        $btn.addClass('ui-icon-arrowthick-1-se');
        $btn.removeClass('ui-icon-arrowthick-1-nw');
      }
    },

    _update: async function (header) {
      var self = this;

      //debugger;

      //console.log(header);

      if (
        header &&
        Object.keys(header).length === 0 &&
        header.constructor === Object
      ) {
      } else {
        var currentGridHead = [];
        var currentGridRecords = [];
        var currentStatuses = [];
        var ticketsPerStatus = {};

        if (!this._isAlive()) return;

        if (typeof header.records_status !== 'undefined')
          currentStatuses = header.records_status;

        if (typeof header.records_graph !== 'undefined') {
          currentGridHead = header.records_graph.gridHead;
          currentGridRecords = header.records_graph.gridRecords;
        }

        if (typeof header.records_action !== 'undefined') {
          var currentActions = header.records_action;
        }

        mdtLogger.log(this, '_update');

        // await this.mapTicketsToStates(currentGridHead, currentGridRecords).then(async function(result) {
        //     var ticketsStates = result[0];
        //     ticketsPerStatus = result[1];
        //     console.log('TicketsStates', ticketsStates);
        //     var ticketsEdges = await self.mapTicketsStatesToEdges(ticketsStates);
        //     console.log('TicketsEdges', ticketsEdges);
        //     return ticketsEdges;
        // }).then(async function(ticketsEdges) {
        //     var edges = await self.generateEdges(ticketsEdges);
        //     console.log('Edges', edges);
        //     self.setUpGraph(currentStatuses, edges, ticketsPerStatus);
        // }).catch(function(err) {
        //     console.error("Error", err.statusText);
        // });

        await this.mapTicketsToStatesAndActions(
          currentGridHead,
          currentGridRecords
        )
          .then(async function (result) {
            var ticketsStates = result[0];
            ticketsPerStatus = result[1];
            // console.log('TicketsStates', ticketsStates);
            // console.log('TicketsPerStatus', ticketsPerStatus);
            var ticketsEdges = await self.mapTicketsStatesAndActionsToEdges(
              ticketsStates,
              currentStatuses.length
            );
            // console.log('TicketsEdges', ticketsEdges);
            return ticketsEdges;
          })
          .then(async function (ticketsEdges) {
            var edges = await self.generateEdgesByActions(ticketsEdges);
            // console.log('Edges', edges);
            self.setUpGraph(
              currentStatuses,
              edges,
              ticketsPerStatus,
              currentActions
            );
          })
          .catch(function (err) {
            //console.error("Error", err.statusText);
            mdtLogger.error('mdt-cyWidget - graph setup', err.message);
          });

        if (header.response == 'idem') {
          // this._startAutoUpdateTimer();
        } else {
          // var colsHeader = ["number"];
          // var newColumn = this.options.gridControl.options.gridModel.columns.length;
          // for (var i = 0, leni = this.options.gridControl.options.gridModel.columns.length; i < leni; i++) {
          //     var column = this.options.gridControl.options.gridModel.columns[i];
          //     if (!column) continue;
          //     var type = column["type"];
          //     colsHeader[i + 1] = type;
          //     if (type == 'datetime' || type == 'date') // || type== 'time')
          //     {
          //         for (var j = 1, lenj = header.records.gridRecords.length; j < lenj; j++) {
          //             header.records.gridRecords[j][i + 1] =
          //                 mdt.makeDate(header.records.gridRecords[j][i + 1])
          //         }
          //     }
          //     if (type == 'time') {
          //         for (var j = 1, lenj = header.records.gridRecords.length; j < lenj; j++) {
          //             var d = mdt.makeDate(header.records.gridRecords[j][i + 1])
          //             var retValue = '';
          //             if (d != null && d != '') {
          //                 var dataValue = moment(d);
          //                 if (!dataValue.isValid()) retValue = 'invalid time';
          //                 else {
          //                     if (dataValue < mdt.limitIncrementTime) {
          //                         retValue = mdt.DateFormatMilliseconds(dataValue.diff(mdt.durationDate0)
          //                             , mdt.gridTimeFormat);
          //                     }
          //                     else {
          //                         try {
          //                             dataValue = mdt.DateFormatMilliseconds(this.options.gridControl.options
          //                                 .widgetRequestTimes['records'].serverTime - dataValue
          //                                 , mdt.gridTimeFormat);
          //                             if (!dataValue.startsWith('+') && !dataValue.startsWith('-'))
          //                                 dataValue = '+' + dataValue;
          //                         }
          //                         catch (ex) {
          //                             dataValue = '?';
          //                         }
          //                         retValue = dataValue;
          //                     }
          //                     if (retValue.indexOf('d') == -1) {
          //                         if (retValue.startsWith('+')) retValue = '+0d ' + retValue;
          //                         else {
          //                             if (retValue.startsWith('-')) retValue = '-0d ' + retValue;
          //                             else retValue = ' 0d ' + retValue;
          //                         }
          //                     }
          //                 }
          //             }
          //             header.records.gridRecords[j][i + 1] = retValue;
          //         }
          //     }
          // }
          // this._updateGraph();
        }
      }
    },

    updateDefaultFilters: function () {
      this.options.defaultFilters = Object.assign(
        {},
        this.options.gridControl.options.gridModel.filtersVal
      );
    },

    _updateGraph: function () {
      this.options.positions = this.options.last_pivot_Options;

      // console.log('Update Graph');

      try {
        this.setNewGraphPositions();
      } catch (ex) {
        mdtLogger.error(
          'mdt-cyWorkflow - update graph - set new positions',
          ex.message
        );
      }
    },

    updateSavedConfigs: function (currentID, newList) {
      this._updateSavedConfigs(currentID, newList);
    },

    _updateSavedConfigs: function (currentID, newList) {
      try {
        var self = this;
        this.options.saved_list_graphs = newList;
        this.options.last_pivot_id = isDefined(currentID) ? currentID : -1;

        // if nothing new
        if (!newList) {
          if (this.options.selectPivotObj) {
            this.options.selectPivotObj.parent().off().remove();
            this.options.selectPivotObj = void 0;
          }

          this._updateSavedConfigsState(this._configStateCode.Default);
          return;
        }

        // if we have items
        var sOptions = '';

        for (
          var i = 0, len = this.options.saved_list_graphs.length;
          i < len;
          i++
        ) {
          try {
            var flt = this.options.saved_list_graphs[i];
            if (flt['id'] != void 0 && flt['name'] != void 0) {
              // fix string values
              if (
                typeof this.options.saved_list_graphs[i]['value'] === 'string'
              )
                this.options.saved_list_graphs[i]['value'] = JSON.parse(
                  this.options.saved_list_graphs[i]['value']
                );

              sOptions +=
                '<option value="' +
                flt['id'] +
                '">' +
                mdt.encodeHtml(flt['name']) +
                '</option>';

              if (this.options.last_pivot_id === -1)
                if ($.trim(flt['name']).toLowerCase() === 'default') {
                  this.options.last_pivot_id = flt['id'];
                  this.options.positions =
                    this.options.saved_list_graphs[i]['value'];
                }
            }
          } catch (ex2) {
            mdtLogger.error(this, '_updateSavedConfigs', ex2.message);
          }
        }

        // create select if does not exist
        if (!this.options.selectPivotObj) {
          //debugger;
          var $fspan = $('.footer-select', this._controls.footer_shell);
          if (!$fspan.length)
            $fspan = $(
              '<span class="footer-select" title=""></span>'
            ).prependTo(this._controls.footer_shell);

          this.options.selectPivotObj = $(
            '<select class="select2"></select>'
          ).appendTo($fspan);
          this._createControl.select(this.options.selectPivotObj.parent());

          //this.options.selectPivotObj
          //    //.on('change.mdt', function () { self._setCustomFilter($(this).val(), 'filterList'); })
          //    .focusin(function () { self._stopAutoUpdateTimer() })
          //    .focusout(function () { self._startAutoUpdateTimer() });
        }

        var oldVal = this.options.selectPivotObj.val();

        //
        this.options.selectPivotObj.find('option').remove();
        this.options.selectPivotObj
          .off('change.mdt') // stop event on recreating select options
          .append(
            /*'<option value="-1"> = Select saved pivot = </option>' +*/ sOptions
          )
          .val(this.options.last_pivot_id)
          .trigger('change')
          .on('change.mdt', function () {
            self._setSavedGraph($(this).val());
          }); // restart event after selection

        // if new val then we trigger the change
        if (oldVal != this.options.last_pivot_id)
          this.options.selectPivotObj.trigger('change.mdt');

        this._updateSavedConfigsState(this._configStateCode.Default);
      } catch (ex) {
        mdtLogger.error(this, '_updateSavedConfigs', ex.message);
      }
    },

    _updateSavedConfigsState: function (state) {
      //debugger;
      this._configState = state || this._configStateCode.Default;

      var onSelection = '',
        offSelection =
          '.save-graph-config, .discard-graph-config, .new-graph-config, .new-pivot-name';

      // reset input value
      $('input.new-pivot-name', this._controls.footer_shell).val('');
      // reset button icon and title
      $('.discard-graph-config > a', this._controls.footer_shell)
        .removeClass('ui-icon-cancel')
        .addClass('ui-icon-trash')
        .attr('title', 'Click to delete selected item');

      //$('.save-graph-config, .discard-graph-config, .new-graph-config, .new-pivot-name').off();
      switch (this._configState) {
        case this._configStateCode.Default:
          if (this.options.saved_list_graphs)
            onSelection = '.save-graph-config, .discard-graph-config,';
          onSelection += '.new-graph-config';
          break;
        case this._configStateCode.AddNewItem:
          onSelection =
            '.save-graph-config, .discard-graph-config, .new-pivot-name';

          $('.discard-graph-config > a', this._controls.footer_shell)
            .removeClass('ui-icon-trash')
            .addClass('ui-icon-cancel')
            .attr('title', 'Cancel');
          break;
        default:
          // no saved items
          onSelection = '.new-graph-config';
          break;
      }
      var self = this;
      $(offSelection, this._controls.footer_shell)
        .removeClass('hover')
        .off()
        .hide();
      if (onSelection)
        $(onSelection, this._controls.footer_shell)
          .show()
          .not('input')
          .on('mouseover', function () {
            $(this).addClass('hover');
          })
          .on('mouseout', function () {
            $(this).removeClass('hover');
          })
          .on('mousedown', function () {
            self._onSavedConfigsClick($(this));
          });
    },

    //#endregion
  });
})((this.mdt = this.mdt || {}), jQuery);
